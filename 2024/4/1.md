## 並行プログラミング入門 4章5章6章

### 概要
並行プログラミングの罠の紹介

Rust による非同期サーバの実装の紹介

シングルスレッド上でのマルチタスクの実装の紹介

### ノート
- デッドロック・ライブロック・飢餓
  - 銀行家のアルゴリズムで解決できる
  - 中途半端にリソースを確保するのをやめる
- 疑似覚醒・シグナル
  - 「シグナルとマルチスレッドは相性が悪い」<- 悪そう
  - ワーカスレッドとシグナル受信用のスレッドを分ければよいらしいが、大変そう
- メモリバリア
  - ちょうど「プログラマーのためのCPU入門」で読んだ内容
  - アーキテクチャごとに特性が異なっていて厄介そう
- 非同期サーバ
  - uvicorn を使ったことがあり、それの中身のイメージができた
  - かなりシンプルな構成でもIOキューと実行キューが出てきて、ややこしい...
    - 特にRust固有の厄介ポイントがかなりありそうで、実装難しそう 
  - tokio のありがたさがわかった
- 協調的マルチタスクと非協調的マルチタスク
  - 前者の場合、無限ループに陥ったタスクがあるとシステムが止まる
  - 後者は実装が複雑になる
    - プリエンプションと呼ばれる協調なしのコンテキストスイッチの実装が必要
- グリーンスレッド
  - ユーザランドのソフトウェアが独自に用意したスレッド機構
  - 本書の実装例では、レジスタ全体をまるっと switch する実装をしている
- アクターモデル
  - 各プロセス（アクター）がそれぞれ独自のキューを持っている並列計算モデル
  - Erlang という言語がそれに特化しているらしい [wiki](https://ja.wikipedia.org/wiki/Erlang)
    - 仮想機械上（Javaみたいなもの？）でプロセス（アクター）を大量に生成できるらしい
