## データ指向アプリケーションデザイン 9章

### 概要
分散システムにおける一貫性と合意の話

裏には厳密な理論の世界があるが、本書では概要に触れるにとどまって色々紹介している

### 気になったことメモ・個人的まとめ
- 線形化可能性(linearizability)
  - レジスタ（キーバリューストアのキーなど）の読み書きにおいて最新性が保証される
    - 処理を前から順に順序付けることができる
    - 一度誰かが見た結果よりも古い結果はその後誰も見ない
  - 直列化可能性とごっちゃになりやすいが、直列化のほうはトランザクションの順序に関するもの
  - 合意アルゴリズムの基盤やユニーク性の保証に使われる
  - マルチリーダーレプリケーションやリーダーレスレプリケーションは一般に線形化可能ではない
  - 逐次一貫性は書き込み関して順序が線形化可能なことを保証する（読み取りは保証しない）
- CAP定理
  - 一貫性・可用性・分断耐性の3つを同時に達成することは不可能という有名な定理
  - 理論的には重要だが、実用的にはあまり価値がないらしい（問題設定が単純すぎるため）
  - 例として、ネットワークが断絶された際に、線形化可能性を保証しようとすると可用性が犠牲になることなどがあげられている
- 因果律による順序
  - 線形化可能性は全順序を要請するもの
  - 実際には、因果律の順序さえ守られていれば十分な場合も多い
  - シーケンス番号を用いることなどにより、因果関係を表現できる
    - シーケンス番号の発行者が複数いるときは発行の仕方は非自明
- ランポートタイムスタンプ
  - あんまりコンピュータ科学者知らない僕でも名前ぐらいは知ってるあのランポート
  - カウンタとノードIDのペアをシーケンス番号として用いることで、因果関係を全順序で表現できるというもの
    - カウンタとして、他のノードから得られたカウンタ値の中で最大のものを採用することが肝
    - 正直、ロジックとしては大したことしてないような気もするが、多分これを厳密に記述して証明するのが大変だったってことなんだろう（多分）
  - 他のノードのカウンタと同期をとる必要があるので、耐障害性が低く、実用からは遠い
- 全順序のブロードキャスト
  - メッセージのロストがなく、かつ全ノードに同じ順序で行われる配信
    - 配信時に順序が確定する
  - 線形化可能な compare-and-set レジスタと全順序ブロードキャストと合意は等価らしい
    - 確かに1つできれば他もできる雰囲気はあるが、やはりお気持ちでしかないのでちゃんとやるなら理論をやる必要がある
- FLP帰結
  - 耳にしたことがなかった言葉
  - 非同期システムモデルにおいてはノードがクラッシュするリスクがある場合は常に合意に達することはできるアルゴリズムはないというものらしい
    - 実際には、非決定性（乱数）を持ち込むだけで回避可能らしい
- 2相コミット
  - 分散処理でアトミックコミットを達成する方法
  - コーディネータというリーダーのような存在を用意して協調を図る
  - 1相目で各ノードがcommitの準備ができたことをコーディネータに通知して、コーディネータからの返事を待って2相目でcommitを反映する
    - ノードがcommit readyを出してから壊れるとシステムが壊れる
    - コーディネータが壊れてもシステムが壊れる
  - 3PCコミットというものもあるが、遅延に上限を設けており、現実では適用が難しいとのこと
  - 2PLは直列化可能性の文脈で出てきたもので、別物
    - write が read を、read が write をブロックするやつ
- XA トランザクション
  - ヘテロジニアスな技術間での2相コミットの標準
  - 参加者はクライアントライブラリやドライバを入れることを想定している
  - 2PCの問題を抱えているので、時には手動でDBを修正する必要があり、大変らしい
- 耐障害性を持つ合意
  - 一様同意・整合性・妥当性・終了性があるが、耐障害の意味で重要なのは終了性
    - 一部が壊れても処理を正常に終える必要がある
  - アルゴリズムとして有名なものの例
    - Viewstamped Replication、Paxos、Raft、Zab
    - Paxos と Raft はどっかで目にしたことがある気がする（中身は知らない）
      - [この辺の記事](https://qiita.com/kumagi/items/535c9b7a761d2ed52bc0)を昔見かけたことがあったので、これかも
      - 次に読もうとしている本はこの辺もう少し詳しく書いてそうなのでその時に見る
  - 合意アルゴリズムを自分で実装するのは険しい道らしい(実感がない)
  - 全順序ブロードキャストは複数回の合意を表すので、全順序ブロードキャストを実装すれば合意は達成される
  - 合意に際しては、過半数の投票によって決定がなされる
    - 2PCでは全参加者の投票が必要だった
- ZooKeeper、etcd
  - 少し前に調べてよくわからんとなっていたサービスの説明がここで軽くされていた
    - 薄々感じてたがアプリケーション開発者が直接触るようなツールではないとのこと
  - ノードがたくさんある際には、これまでに触れてきたように障害検出や操作の順序付けは簡単なタスクではないが、それをサポートしてくれるツール
    - 合意アルゴリズムにより障害からの自動回復もできる
    - 確かに合意アルゴリズムとか真面目に実装しようと思うとめちゃくちゃ大変そうなのでかなり便利そうで、アプリケーション開発者が普段触るような分散処理フレームワークの裏にはこういったサービスが動いていることがよくありそう

### 所感
こういう話を読んでると、もう少し中身に興味が出てくるもの（頑張って隠してるのを随所で感じる）

次読む予定の本はもう少し具体的な中身に踏み込んでそうなので少し楽しみ
