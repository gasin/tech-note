## データ指向アプリケーションデザイン 7章

### 概要
トランザクションという概念の導入及び分離レベルの紹介

### 気になったことメモ
- トランザクション
  - 障害や競合を考慮するために導入された概念で、複数の読み書きを論理的にまとめたもの
  - DBがトランザクションの結果（commit, abort, rollback）を返すようにすることでアプリケーション側でハンドリングできるようにする
  - 分散データストアでは複数オブジェクトのトランザクションの実装の難易度が高く、放棄していることも多いらしい
    - 後の章で扱う
- ACID
  - Atomicity
    - 1つのトランザクション内において、中途半端に変更が DB に反映されないこと
    - マルチスレッドプログラミングの文脈では、スレッド間の処理において割り込まれないことを指すので、それとは少し違う概念
  - Concictency
    - これは Application 特性で、もともと ACID の中に含まれていなかったらしい（初耳）
  - Isolation
    - 複数のクライアントによる読み書きで競合が発生しないようにすること
  - Durability
    - commit された変更について、DB に保管され続けることを保証すること
    - 最近だとレプリケーションまでして Durability と解釈されるらしい
      - 身近な感覚だと SSD に保存したら永続性といいたくなるが障害なども考慮する必要がある
- 分離レベル
  - 最強なのは serializability（直列化可能分離レベル）
    - トランザクションを直列にするので、競合が起きない
    - パフォーマンスに懸念があるので、弱い分離レベルが色々ある 
  - read committed
    - dirty read や dirty write（DB上の読み書きにおいてトランザクション中のデータを参照してしまうこと）を防ぐ
    - 読み書きをしているデータにロックをかけることで実現可能
      - 読み側については、変更中の前の値を見れるようにすることでロックをかけないでも実現可能
    - あるトランザクションを処理している途中にほかのトランザクションが完了することにより状態が変化し一貫性が崩れるという、read skew のような問題が起きうる
  - スナップショット分離
    - read committed の read skew 問題を解決するもの
    - あるトランザクション内の読み取りはトランザクション開始時の DB の状態（スナップショット）からのみ行うというもの
      - 読み取り側ではロックを意識する必要がない
    - ある時点での DB の状態を管理する必要があるので、MVCC（multi-version concurrency control）という仕組みが使われ、読み取り対象のデータにトランザクションIDを付与して管理する
      - データ削除についても、いきなり DB から削除するのではなく、削除操作が来たということをまずは記録する
      - MVCC の実装はインデックスの処理も必要で、ツールによって最適化がされている
    - リピータブルリードとも呼ばれる
      - PostgreSQL は repeatable read [page](https://www.postgresql.org/docs/16/transaction-iso.html)
        - ところで PostgreSQL の wiki めちゃくちゃ充実しててすごい

- 更新のロスト
  - 平行に同じカウンタの更新が来た際に、巻き戻しが起こるというようなもの
  - 「前の状態から+1する」のように更新をアトミックに表現できれば問題ない
  - 他にも、明示的にロックをとったり、compare-and-set と呼ばれる書き込みの際に読み込み時と状態が変更してないことを確認する、などをすることで回避できる
- write skew
  - 全ユーザが inactive なら自分を active にするというトランザクションが 2 つ並行
  に来た場合、2重に active にする処理が走るというような問題
    - 書き込みによって他のトランザクションの検索に影響を与える効果をファントムと呼ぶ
  - 明示的なロックを使えば解決はできる
    - アプリケーション側の負担が増える
  - 全ユーザが inactive かどうかというデータを管理することで write のロックが欠けられるので解決する
    - 衝突の実体化と呼ばれる対策だが、一般には実体化の仕方が明らかでない
- 直列化可能分離レベル
  - 並列に読み書きを行おうとすると結局何かしらの競合が問題になるので、理想では直列化可能分離レベルを使いたい
  - シングルスレッドで直列に処理をすれば容易に実現はできる
    - パフォーマンスに問題があるが、もともとシングルスレッド用のサービスなら問題ない
    - redis などで採用されている
  - 1つのトランザクションの処理に時間がかかると詰まるので、ストアドプロシージャと呼ばれる、トランザクション中に外部との通信などを含まない一連の処理が DB に渡される
- two phase lock
  - 直列化可能分離レベルの実現法の1つ
  - スナップショット分離レベルと似ているが、リーダー及びライターがリーダーとライター両方をロックするようになる
    - read committed だとリーダーはリーダー、ライターはライターのみロックしていた
  - デッドロックが生じやすくなるうえ、ロックされる時間も長いのでパフォーマンスに懸念がある
  - lock
    - 述語ロック
      - ロックすべき条件を述語で記述する
      - DB にまだ存在していないデータも記述できるのが鍵らしい
      - 述語を処理するのに時間がかかるのが懸念
    - インデックス範囲ロック
      - 述語を単純化して、範囲でロックをかける方法
      - ロックをかける範囲は必要な分より大きくなるが、オーバーヘッドが小さいので実践的
- 直列可能なスナップショット分離（serializable snapshot isolation, SSI）
  - 直列化可能な分離レベルはパフォーマンスに問題があり、スナップショット分離にはまだ競合の処理に懸念があったので、その間のような立ち位置のもの
    - スナップショット分離の際に問題になった write skew の解決が焦点
  - 楽観的な並行性制御と呼ばれる仕組みのもので、処理が終わった段階で DB に問題がなければよいというスタンスになっている
    - 逆に、悲観的な平衡性制御の場合は、律儀に順に処理をする必要がある
  - write skew においては、read -> write のトランザクションにおいて、write を行う時点で DB が read の状態から更新されているのが問題だった
    - write のタイミングで、read が更新されていたら、トランザクションを中断することで解決する
      - 既に更新されていたがまだ commit されていなかったものと、読み取り後に更新されたの2パターンがある
      - いずれの場合も MVCC スナップショットを管理して検知・通知する
  - パフォーマンスは中断が発生する度合いに依存するが、スケーリング可能であるメリットがある
    - ライブラリによっては、更新があってもトランザクションに影響がなければ中断しないというロジックも実装されている
