## データ指向アプリケーションデザイン 11章

### 概要
ストリーム処理についての概要

データが途切れることなく無限に流れてくるのをどう捌くかが焦点

### 気になったことメモ・個人的まとめ
- メッセージブローカー
  - プロデューサとコンシューマの仲介をするもの
  - Google Cloud Pub/Sub がこれ
  - ログベースメッセージブローカーは、メッセージのログを記録する機能をつけたもの
    - パーティションやメッセージの保持期間など、考えることは増える
- 複数のコンシューマに向けるメッセージの種類
  - ロードバランシング
    - どれか1つのコンシューマに配信されれば十分なメッセージ
    - 分散処理など
  - ファンアウト
    - 全てのコンシューマに配信されるメッセージ
    - 通知など
  - 組み合わせることで、コンシューマグループのうち1つに送るということもできる
- イベントソーシング
  - DDD から生まれたものらしい（最近 DDD 学んでる）
  - アプリケーションレベルで処理を制御するので、ストリームで流れてくる処理についても順序をアプリケーション側で判断してログに残せる
  - ユーザからのリクエストがコマンドで、検証に成功したらイベントになるらしい
    - DDD のサンプルコードを見ていると書き込み処理に command という単語が使われていたが、ここと結びついた
  - コマンドクエリ責務分離 CQRS
    - 基本的に複雑になるのは読み取り側の処理
    - 書き込み処理と読み込み処理とでデータモデルを分離することで、柔軟性を上げる
    - コマンドクエリ分離 CQS という似た言葉があるが、こちらはメソッドレベルでの分離で、データモデルは対象としてないみたい
- ストリーム処理
  - ストリームデータについて、イベントの抽出やメトリクスの収集を行いたくなる場面がある
    - 典型的にはアプリケーションのアクセスログの分析など
  - メッセージの発生時、メッセージの送信時、メッセージの受信時と色々タイミングがずれる要因があるので、イベントにタイムスタンプを振るのは単純ではない
    - これらの時間のオフセットを計算することで推定はできる
  - ストリームのデータについては、データを取得する期間（window）を決める必要がある
    - タンブリングウィンドウ（固定幅）やスライディングウィンドウ（メッセージ駆動での動的幅）など色々ある
- ストリーム処理の耐障害性
  - バッチ処理は冪等性があったが、ストリーム処理にはそれがないので対処が必要
  - ストリームを小さなバッチ処理に分割することで対策するのはマイクロバッチ処理と呼ばれる
    - オーバーヘッドはあるが、現実的な解決策
    - 障害があった時に再実行すると副作用が2回走る問題は残っている
      - 対処するにはアトミックなコミットを実現する必要がある
      - 制約が強い環境下では分散トランザクションほど複雑でなく、Google Cloud Dataflow ではこのアプローチが使われている
