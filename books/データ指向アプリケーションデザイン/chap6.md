## データ指向アプリケーションデザイン 6章

### 概要
シャーディングの概要と主な手法の紹介

### 気になったことメモ・個人的まとめ
- パーティション
  - 別名、シャード（個人的にはシャーディングという言葉で目にすることが多かった）
  - 主にスケーラビリティのために導入される
  - レプリケーションと同時に用いられることもある
    - 本書では独立に扱っている
- データの分け方
  - 処理が一か所に集中（skew）したら、効率的でない
  - クエリの局所性をごまかすために、キーの先頭に値を挿入したり、ハッシュ関数をかませたりする
    - 確かに、Cloud Spanner について調べているときこういう話があった
  - 範囲に対するクエリについてはバラバラにされると効率が落ちるので、複合プライマリキーを宣言するなどして、パーティション内でまとめて管理することもできる
  - 同じ箇所への更新や読み取りが集中したら、パーティションも意味がない
    - アプリケーション側でキーを分割するなどの対応をすることになる
- コンシステントハッシュ法
  - キーのハッシュ値に基づいてサーバにデータを割り振る方法の1つ
  - 円環上にサーバに対応するハッシュ値を配置し、各キーのハッシュ値について、自身よりも大きいかつ最も小さいハッシュ値を持つサーバに割り当てる
    - サーバの追加・削除が効率よく行える
    - サーバの追加・削除によって偏りが生じうるので、多くの仮想サーバを円環上に配置して、複数の仮想サーバをサーバに割り振るとよいらしい
  - 類似の手法に[Rendezvous Hashing](https://randorithms.com/2020/12/26/rendezvous-hashing.html)というものがある
    - キーをソルトとしてサーバごとのハッシュ値をソートして、先頭から k 個用意する
    - サーバを消す場合は、キーごとに対応するサーバ k 個を前から見て、生きているサーバにデータを移す
    - コンシステントハッシュに比べて、シンプルな仕組みで偏りが生じにくいのがメリットとして挙げられる
    - 一方、サーバの追加が単純ではない点やコンシステントハッシュと比べると検索の計算量が悪いのが欠点（サーバの台数が少ないならほぼ関係ない）
- セカンダリインデックスへの対応
  - 処理を高速化するために有用なことが多いので、パーティションを使ってもサポートしたい
  - パーティションごとに自分のところにあるデータのセカンダリインデックスを構築する方法と、グローバルのセカンダリインデックスをパーティションごとに分割して管理する方法がある
    - 前者は全てのパーティションにクエリを送る必要がある 
    - 後者はグローバルにセカンダリインデックスを管理することになるので書き込みが低速で複雑
- リバランシング
  - ノードの追加や更新に伴い、データを再割り振りすること
  - 移動させるデータは少なくしたいので、ハッシュの剰余などは使いたくない
  - パーティションの粒度を小さくしておけば、ノードが追加された際に、既存のノードからパーティションを取ってくることで無駄なデータ移動なくリバランシングできる
    - パーティションが固定だとデータの偏りが発生しうるので、動的にパーティションを行う仕組みも使われている
- サービスディスカバリ
  - クライアントのクエリを度のノードに投げればいいのかを扱うサービス
  - ノードごとに用意するか、ルーティング層を用意するか、クライアント側に用意するかがある
    - ルーティング層にて使われるサービスとして[ZooKeeper](https://en.wikipedia.org/wiki/Apache_ZooKeeper)が紹介されている
      - 本文中では、キー・パーティション・ノード・IPアドレスを管理してくれるサービスぐらいのノリで書かれている
      - ググると、分散処理の協調部分を担当するサービスで、元は Hadoop のサブプロジェクトだったらしい
      - [document](https://zookeeper.apache.org/doc/r3.9.1/zookeeperOver.html)を見ると、ZooKeeper のサービス自体がリーダーベースレプリケーションのアーキテクチャになっている
      - 正直よくわからなかったが、まぁ分散処理するときに、ノードやサービスの管理を楽にしてくれるものぐらいの認識をした

