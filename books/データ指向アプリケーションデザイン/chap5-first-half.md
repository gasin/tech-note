## データ指向アプリケーションデザイン 5章前半

### 概要
DB におけるレプリケーションの仕組み前半

### 気になったことメモ・自分用まとめ
- レプリケーションのモチベーション
  - 地理的に近いことによる低レイテンシ・耐障害性・読み取りのスケールアウト
  - 正直最後以外の恩恵を感じる機会は個人的にはほぼないが、話としては分かる
- リーダーベースレプリケーション
  - 読み書きを受け付けるリーダーと読み取りを受け付けるフォロワー達の構成
  - 書き込みをいつフォロワーに反映させ、整合性や耐障害性を担保するかが課題になる
    - 全てのフォロワーと同期するのは一般に現実的でないため、（準）同期と呼ばれる1つのフォロワーと同期する仕組みが使われる
    - 少なくとも2箇所にデータが存在していることが保証されるのでデータが失われにくい
- 障害対策 
  - フォロワーの障害はリーダーのログをもとに復旧できる
    - 新しいフォロワーの追加も同様
  - リーダーの障害
    - フェイルオーバーとよばれる
    - レプリカの中から新しいリーダーを選出して復旧する
      - リーダーの決め方や、非同期性により自動でやるのはかなり難しいみたい
      - 前者の合意の話は後の章でやるらしい
    - Alloy DB が primary node 1つと read only nodes で構成されてかつ HA うたってたなと思い見てみたら、primary node の複製が別の zone に配置されていて、自動でフェイルオーバーが達成されるらしい
      - https://cloud.google.com/alloydb/docs/overview#ha
      - 余剰分コストはかかるが、フォロワー使ってごにょごにょするよりは単純でよさそう
  - 復旧用ログの取り方
    - 単純には操作を順にログとして取ればいいように思うが、日時や乱数・副作用などがあり単純ではない
    - ステートメントベース、WALログ、論理ログなどがある
      - GCP の DB サービス見ていた時は WAL をよく見かけた気がする
      - [wiki](https://ja.wikipedia.org/wiki/%E3%83%AD%E3%82%B0%E5%85%88%E8%A1%8C%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF)がわかりやすい
- レプリケーションラグ
  - 書き込みは全フォロワーに同期的に更新されないので、ラグが生じる
  - ただし、書き込んだ本人は書き込みが同期的に反映されてほしいなどの要望がある
    - 一部については読み取りをフォロワーではなくリーダー側で行うことにより対応できる
    - リーダーの負担が大きくなるので、処理能力を見ながら何を任せるか決めることになりそう
    - どの書き込みとどの読み取りを同期にするべきかは決め事で難しい様子（クロスデバイスなど）
  - フォロワー間で反映に差があると、処理を担当するフォロワーが変わった時に状態が過去に戻ったり、守られているべき順序が逆転したりする
    - モノトニック一貫性・一貫したプレフィックス読み取りなどでこれらが起きないことを保証する
  - このラグの対策としてトランザクションという概念があるらしい
    - 今まで雰囲気で使っていたが、後の章で詳しくやるとのことで楽しみ
- SQL Alchemy の session
  - トランザクションがあるなら session はなんだっけとなった
  - https://docs.sqlalchemy.org/en/20/orm/session_transaction.html
    - session はトランザクションを管理するもの（DB に直接関係あるわけではない）
    - トランザクションをネストさせることが可能だったりと、開発が便利になるというのがメリットみたい
